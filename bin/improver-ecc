#!/usr/bin/env python
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# (C) British Crown Copyright 2017 Met Office.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
"""Script to run Ensemble Copula Coupling processing."""

import argparse

import iris
from iris.exceptions import CoordinateNotFoundError

from improver.ensemble_copula_coupling.ensemble_copula_coupling import (
    RebadgePercentilesAsMembers, ResamplePercentiles,
    GeneratePercentilesFromProbabilities, EnsembleReordering)


def main():
    """Load in arguments and get going."""
    parser = argparse.ArgumentParser(
    description='Apply the requested neighbourhood method via '
                'the NeighbourhoodProcessing plugin '
                'to a file with one cube.')
    conversion_option_group = parser.add_mutually_exclusive_group()
    reordering_group = conversion_option_group.add_mutually_exclusive_group()
    reordering_group.add_argument(
        '--reordering', action='store_true',
        help='The option used to create ensemble members '
             'from percentiles by reordering the input '
             'percentiles based on the order of the '
             'raw ensemble forecast.')
    reordering_group.add_argument('--raw_forecast_filepath',
                        metavar='RAW_FORECAST_FILE',
                        help='A path to an raw forecast NetCDF file to be '
                             'processed.')
    reordering_group.add_argument('--random_ordering', action='store_false',
                        help='Decide whether or not to use random ordering '
                             'within the ensemble reordering step.' )

    rebadging_group = conversion_option_group.add_mutually_exclusive_group()
    rebadging_group.add_argument(
        '--rebadging', action='store_true',
        help='The option used to create ensemble members '
              'from percentiles by rebadging the input '
              'percentiles.')
    rebadging_group.add_argument('--member_numbers', default=False,
                        metavar='MEMBER_NUMBERS',
                        help='A list of ensemble member numbers to use '
                             'when rebadging the percentiles into members.')

    parser.add_argument('input_filepath', metavar='INPUT_FILE',
                        help='A path to an input NetCDF file to be processed')
    parser.add_argument('output_filepath', metavar='OUTPUT_FILE',
                        help='The output path for the processed NetCDF')
    parser.add_argument('--no_of_percentiles', nargs=1, default=None,
                        metavar='NUMBER_OF_PERCENTILES',
                        help='The number of percentiles to be generated.')
    parser.add_argument('--sampling_method', default='quantile',
                        const='quantile', nargs='?',
                        choices=['quantile', 'random'],
                        metavar='PERCENTILE_SAMPLING_METHOD',
                        help='Method to be used for generating the list of '
                             'percentiles with forecasts generated at each '
                             'percentile. "quantile" is the default option.')
    args = parser.parse_args()
    cube = iris.load_cube(args.input_filepath)

    coords = (coord for coord in cube.coords() if "threshold" in coord.name())

    if cube.coords("percentile"):
        result_cube = ResamplePercentiles().process(
            cube, no_of_percentiles=int(args.no_of_percentiles[0]),
            sampling=args.sampling_method)
    elif len(list(coords))>0:
        result_cube = GeneratePercentilesFromProbabilities().process(
            cube, no_of_percentiles=int(args.no_of_percentiles[0]),
            sampling=args.sampling_method)
    else:
        msg = ("The input cube: {} does not have either a percentile "
               "dimension or a dimension representing a "
               "threshold.".format(cube))
        raise CoordinateNotFoundError(msg)

    if args.reordering:
        raw_forecast = iris.load_cube(args.raw_forecast_filepath)
        result_cube = EnsembleReordering().process(
            cube, raw_forecast, random_ordering=args.random_ordering)
    elif args.rebadging:
        result_cube = RebadgePercentilesAsMembers().process(
            cube, ensemble_member_numbers=args.member_numbers)
    else:
        msg = "Either the reordering or the rebadging option must be selected."
        parser.error(msg)

    iris.save(result_cube, args.output_filepath)


if __name__ == "__main__":
    main()