#!/usr/bin/env python
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# (C) British Crown Copyright 2017 Met Office.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
"""Script to run Ensemble Copula Coupling processing."""

import argparse

import iris
from iris.exceptions import CoordinateNotFoundError

from improver.ensemble_copula_coupling.ensemble_copula_coupling import (
    RebadgePercentilesAsMembers, ResamplePercentiles,
    GeneratePercentilesFromProbabilities, EnsembleReordering)


#class _HelpAction(argparse._HelpAction):

    #def __call__(self, parser, namespace, values, option_string=None):
        #parser.print_help()

        ## retrieve subparsers from parser
        #subparsers_actions = [
            #action for action in parser._actions
            #if isinstance(action, argparse._SubParsersAction)]
        ## there will probably only be one subparser_action,
        ## but better save than sorry
        #for subparsers_action in subparsers_actions:
            ## get all subparsers and print help
            #for choice, subparser in subparsers_action.choices.items():
                #print("Subparser '{}'".format(choice))
                #print(subparser.format_help())

        #parser.exit()


def main():
    """Load in arguments and get going."""
    parser = argparse.ArgumentParser(
        description='Apply the requested neighbourhood method via '
                    'the NeighbourhoodProcessing plugin '
                    'to a file with one cube.', add_help=False)

    parser.add_argument("-h", "--help", action=_HelpAction, help="help for help if you need some help")

    subparsers = parser.add_subparsers(
        help='help for subcommand', dest="subparser")

    reordering_parser = subparsers.add_parser('reordering', 
        help='The option used to create ensemble members '
             'from percentiles by reordering the input '
             'percentiles based on the order of the '
             'raw ensemble forecast.')
    #reordering_parser.set_defaults(reordering=True)
    reordering_parser.add_argument('raw_forecast_filepath',
                        metavar='RAW_FORECAST_FILE',
                        help='A path to an raw forecast NetCDF file to be '
                             'processed.')
    reordering_parser.add_argument('--random_ordering',
                        help='Decide whether or not to use random ordering '
                             'within the ensemble reordering step.' )

    rebadging_parser = subparsers.add_parser('rebadging',
        help='The option used to create ensemble members '
              'from percentiles by rebadging the input '
              'percentiles.')
    #rebadging_parser.set_defaults(rebadging=True)
    rebadging_parser.add_argument('--member_numbers', default=None,
        metavar='MEMBER_NUMBERS',
        help='A list of ensemble member numbers to use '
              'when rebadging the percentiles into members.')

    #conversion_option_group = parser.add_mutually_exclusive_group()
    #reordering_group = conversion_option_group.add_mutually_exclusive_group()
    #reordering_group.add_argument(
        #'--reordering', action='store_true',
        #help='The option used to create ensemble members '
             #'from percentiles by reordering the input '
             #'percentiles based on the order of the '
             #'raw ensemble forecast.')
    #reordering_group.add_argument('--raw_forecast_filepath',
                        #metavar='RAW_FORECAST_FILE',
                        #help='A path to an raw forecast NetCDF file to be '
                             #'processed.')
    #reordering_group.add_argument('--random_ordering', action='store_false',
                        #help='Decide whether or not to use random ordering '
                             #'within the ensemble reordering step.' )

    #rebadging_group = conversion_option_group.add_mutually_exclusive_group()
    #rebadging_group.add_argument(
        #'--rebadging', action='store_true',
        #help='The option used to create ensemble members '
              #'from percentiles by rebadging the input '
              #'percentiles.')
    #rebadging_group.add_argument('--member_numbers', default=False,
                        #metavar='MEMBER_NUMBERS',
                        #help='A list of ensemble member numbers to use '
                             #'when rebadging the percentiles into members.')

    parser.add_argument('input_filepath', metavar='INPUT_FILE',
                        help='A path to an input NetCDF file to be processed')
    parser.add_argument('output_filepath', metavar='OUTPUT_FILE',
                        help='The output path for the processed NetCDF')
    parser.add_argument('--no_of_percentiles', nargs=1, default=None,
                        metavar='NUMBER_OF_PERCENTILES',
                        help='The number of percentiles to be generated.')
    parser.add_argument('--sampling_method', default='quantile',
                        const='quantile', nargs='?',
                        choices=['quantile', 'random'],
                        metavar='PERCENTILE_SAMPLING_METHOD',
                        help='Method to be used for generating the list of '
                             'percentiles with forecasts generated at each '
                             'percentile. "quantile" is the default option.')
    args = parser.parse_args()

    cube = iris.load_cube(args.input_filepath)

    coords = (coord for coord in cube.coords() if "threshold" in coord.name())

    if cube.coords("percentile"):
        result_cube = ResamplePercentiles().process(
            cube, no_of_percentiles=int(args.no_of_percentiles[0]),
            sampling=args.sampling_method)
    elif len(list(coords))>0:
        result_cube = GeneratePercentilesFromProbabilities().process(
            cube, no_of_percentiles=int(args.no_of_percentiles[0]),
            sampling=args.sampling_method)
    else:
        msg = ("The input cube: {} does not have either a percentile "
               "dimension or a dimension representing a "
               "threshold.".format(cube))
        raise CoordinateNotFoundError(msg)

    if args.subparser == "reordering":
        raw_forecast = iris.load_cube(args.raw_forecast_filepath)
        result_cube = EnsembleReordering().process(
            result_cube, raw_forecast, random_ordering=args.random_ordering)
    elif args.subparser == "rebadging":
        result_cube = RebadgePercentilesAsMembers().process(
            result_cube, ensemble_member_numbers=args.member_numbers)
    else:
        msg = "Either the reordering or the rebadging option must be selected."
        parser.error(msg)
    iris.save(result_cube, args.output_filepath)


if __name__ == "__main__":
    main()