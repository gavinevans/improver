# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# (C) British Crown Copyright 2017-2021 Met Office.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
"""
Unit tests for the
`ensemble_calibration.EstimateCoefficientsForEnsembleCalibration`
class.

"""
import datetime
import importlib
import unittest
from functools import partial

import iris
import numpy as np
from iris.tests import IrisTest

from improver.calibration.ensemble_calibration import (
    EstimateCoefficientsForEnsembleCalibration as Plugin,
)
from improver.metadata.utilities import generate_mandatory_attributes
from improver.synthetic_data.set_up_test_cubes import set_up_variable_cube
from improver.utilities.warnings_handler import ManageWarnings

from .helper_functions import (
    EnsembleCalibrationAssertions,
    SetupCubes,
    _create_historic_forecasts,
)

try:
    importlib.import_module("statsmodels")
except (ModuleNotFoundError, ImportError):
    STATSMODELS_FOUND = False
else:
    STATSMODELS_FOUND = True


IGNORED_MESSAGES = [
    "Collapsing a non-contiguous coordinate",  # Originating from Iris
    "invalid escape sequence",  # Originating from statsmodels
    "can't resolve package from",  # Originating from statsmodels
    "Minimisation did not result in convergence",  # From calibration code
    "The final iteration resulted in",  # From calibration code
    "Invalid value encountered in",  # From calculating percentage change in
    # calibration code
    "The statsmodels module cannot be imported",
]
WARNING_TYPES = [
    UserWarning,
    DeprecationWarning,
    ImportWarning,
    UserWarning,
    UserWarning,
    RuntimeWarning,
    ImportWarning,
]

class SetupExpectedCoefficients(IrisTest):

    """Expected coefficients generated by EMOS using the test data."""

    def setUp(self):
        """Set up expected coefficients and coefficient names."""
        super().setUp()
        self.coeff_names = ["alpha", "beta", "gamma", "delta"]
        self.expected_coeff_names = [f"emos_coefficient_{s}" for s in self.coeff_names]

        # The expected coefficients for temperature in Kelvin.
        self.expected_mean_predictor_norm = np.array(
            [25.0839, 0.9071, 0.0013, 0.4833], dtype=np.float32
        )
        # The expected coefficients for wind speed in m s^-1.
        self.expected_mean_predictor_truncnorm = np.array(
            [-0.5744, 0.9529, -0.0069, 1.2312], dtype=np.float32
        )

        self.expected_realizations_norm_statsmodels = np.array(
            [-0.2838, -0.0774, 0.3892, 0.9167, -0.0003, 1.0022], dtype=np.float32
        )
        self.expected_realizations_norm_no_statsmodels = np.array(
            [-0.0, 0.5786, 0.578, 0.5734, 0.0001, 1.0175,], dtype=np.float32
        )
        self.expected_realizations_truncnorm_statsmodels = np.array(
            [-0.606, -0.0623, 0.3786, 0.9014, 0.0003, 1.2571], dtype=np.float32
        )
        self.expected_realizations_truncnorm_no_statsmodels = np.array(
            [0.0003, 0.56927171, 0.5056, 0.5344, 0.0004, 1.0712], dtype=np.float32
        )


class Test__init__(SetupCubes):

    """Test the initialisation of the class."""

    def setUp(self):
        """Set up variables for testing."""
        self.distribution = "norm"
        self.desired_units = "degreesC"

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coeff_names(self):
        """Test that the plugin instance defines the expected
        coefficient names."""
        expected = ["alpha", "beta", "gamma", "delta"]
        plugin = Plugin(self.distribution,)
        self.assertEqual(plugin.coeff_names, expected)

    def test_invalid_distribution(self):
        """Test an error is raised for an invalid distribution"""
        distribution = "biscuits"
        msg = "Given distribution biscuits not available. "
        with self.assertRaisesRegex(ValueError, msg):
            Plugin(distribution)


class Test_create_coefficients_cubelist(SetupExpectedCoefficients):

    """Test the create_coefficients_cubelist method."""

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def setUp(self):
        """Set up the plugin and cubes for testing."""
        super().setUp()
        frt_dt = datetime.datetime(2017, 11, 10, 0, 0)
        time_dt = datetime.datetime(2017, 11, 10, 4, 0)
        data = np.ones((3, 3), dtype=np.float32)
        self.historic_forecast = _create_historic_forecasts(
            data, time_dt, frt_dt,
        ).merge_cube()
        data_with_realizations = np.ones((3, 3, 3), dtype=np.float32)
        self.historic_forecast_with_realizations = _create_historic_forecasts(
            data_with_realizations, time_dt, frt_dt, realizations=[0, 1, 2],
        ).merge_cube()
        self.optimised_coeffs = np.array([0, 1, 2, 3], np.int32)

        self.distribution = "norm"
        self.desired_units = "degreesC"
        self.predictor = "mean"
        self.plugin = Plugin(
            distribution=self.distribution,
            desired_units=self.desired_units,
            predictor=self.predictor,
        )
        self.expected_frt = (
            self.historic_forecast.coord("forecast_reference_time").cell(-1).point
        )
        self.expected_fp = self.historic_forecast.coord("forecast_period")
        self.expected_x_coord_points = np.median(
            self.historic_forecast.coord(axis="x").points
        )
        self.expected_x_coord_bounds = np.array(
            [
                [
                    np.min(self.historic_forecast.coord(axis="x").bounds),
                    np.max(self.historic_forecast.coord(axis="x").bounds),
                ]
            ]
        )
        self.expected_y_coord_points = np.median(
            self.historic_forecast.coord(axis="y").points
        )
        self.expected_y_coord_bounds = np.array(
            [
                [
                    np.min(self.historic_forecast.coord(axis="y").bounds),
                    np.max(self.historic_forecast.coord(axis="y").bounds),
                ]
            ]
        )
        self.attributes = generate_mandatory_attributes([self.historic_forecast])
        self.attributes["diagnostic_standard_name"] = self.historic_forecast.name()
        self.attributes["distribution"] = self.distribution
        self.attributes["title"] = "Ensemble Model Output Statistics coefficients"

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficients_from_mean(self):
        """Test that the expected coefficient cube is returned when the
        ensemble mean is used as the predictor."""
        result = self.plugin.create_coefficients_cubelist(
            self.optimised_coeffs, self.historic_forecast
        )
        self.assertEqual(len(result), 4)
        for cube in result:
            self.assertEqual(
                cube.coord("forecast_reference_time").cell(0).point, self.expected_frt,
            )
            self.assertEqual(
                cube.coord("forecast_period"), self.expected_fp,
            )
            self.assertArrayAlmostEqual(
                cube.coord(axis="x").points, self.expected_x_coord_points
            )
            self.assertArrayAlmostEqual(
                cube.coord(axis="x").bounds, self.expected_x_coord_bounds
            )
            self.assertArrayAlmostEqual(
                cube.coord(axis="y").points, self.expected_y_coord_points
            )
            self.assertArrayAlmostEqual(
                cube.coord(axis="y").bounds, self.expected_y_coord_bounds
            )
            self.assertDictEqual(cube.attributes, self.attributes)

        self.assertEqual([cube.name() for cube in result], self.expected_coeff_names)

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coordinates_from_mean_period_diagnostic(self):
        """Test that the time coordinates are as expected when the historic
        forecasts are time-bounded diagnostics, e.g. maximum in hour."""

        fp_bounds = [10800, 14400]

        self.historic_forecast.coord("forecast_period").bounds = fp_bounds
        self.expected_fp.bounds = fp_bounds

        result = self.plugin.create_coefficients_cubelist(
            self.optimised_coeffs, self.historic_forecast
        )
        self.assertEqual(len(result), 4)
        for cube in result:
            self.assertEqual(
                cube.coord("forecast_reference_time").cell(0).point, self.expected_frt,
            )
            self.assertEqual(
                cube.coord("forecast_period"), self.expected_fp,
            )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_exception_for_multi_valued_forecast_period(self):
        """Test that an exception is raised if the forecast_period is multi-
        valued. This is simply to demonstrate that only single valued
        forecast periods are expected."""

        fps = [0, 3600, 7200, 10800, 14400]
        fp_coord = self.historic_forecast.coord("forecast_period").copy(fps)
        self.historic_forecast.remove_coord("forecast_period")
        self.historic_forecast.add_aux_coord(fp_coord, 0)

        msg = "The forecast period must be the same"
        with self.assertRaisesRegex(ValueError, msg):
            self.plugin.create_coefficients_cubelist(
                self.optimised_coeffs, self.historic_forecast
            )

    def test_attributes_for_truncnorm(self):
        """Test that the expected attributes are created for a truncated normal
        distribution."""
        distribution = "truncnorm"
        self.attributes["distribution"] = distribution
        self.attributes["shape_parameters"] = np.array([0, np.inf], dtype=np.float32)

        plugin = Plugin(
            distribution=distribution,
            desired_units=self.desired_units,
            predictor=self.predictor,
        )
        result = plugin.create_coefficients_cubelist(
            self.optimised_coeffs, self.historic_forecast
        )
        for cube in result:
            self.assertDictEqual(cube.attributes, self.attributes)

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficients_from_realizations(self):
        """Test that the expected coefficient cube is returned when the
        ensemble realizations are used as the predictor."""
        predictor = "realizations"
        optimised_coeffs = [0, 1, 2, 3, 4, 5]

        plugin = Plugin(
            distribution=self.distribution,
            desired_units=self.desired_units,
            predictor=predictor,
        )
        result = plugin.create_coefficients_cubelist(
            optimised_coeffs, self.historic_forecast_with_realizations
        )
        self.assertEqual([cube.name() for cube in result], self.expected_coeff_names)
        self.assertArrayEqual(
            result.extract("emos_coefficient_beta", strict=True)
            .coord("realization")
            .points,
            self.historic_forecast_with_realizations.coord("realization").points,
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_too_few_coefficients(self):
        """Test that an exception is raised if the number of coefficients
        provided for creating the coefficients cube is not equal to the
        number of coefficient names."""
        distribution = "truncnorm"
        desired_units = "Fahrenheit"
        predictor = "mean"
        optimised_coeffs = [1, 2, 3]
        plugin = Plugin(
            distribution=distribution, desired_units=desired_units, predictor=predictor,
        )
        msg = "The number of coefficients in"
        with self.assertRaisesRegex(ValueError, msg):
            plugin.create_coefficients_cubelist(
                optimised_coeffs, self.historic_forecast
            )


def _create_multi_date_cube(data):
    """Create a cube with a time dimension coordinate.

    Args:
        data (numpy.ndarray):
            Array that will be repeated for each date.

    Returns:
        iris.cube.Cube:
            Cube containing a time dimension coordinate.
    """
    cubes = iris.cube.CubeList()
    for day in range(1, 3):
        cubes.append(set_up_variable_cube(data,
            time=datetime.datetime(2017, 11, day, 4, 0),
            frt=datetime.datetime(2017, 11, day, 0, 0),
            units="Kelvin", realizations=[0, 1, 2]))
    return cubes.merge_cube()


class Test_compute_initial_guess(IrisTest):

    """Test the compute_initial_guess method."""

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def setUp(self):
        """
        Use temperature cube to test with. Also set up versions with a masked
        halo surrounding the original data.
        Set up expected results for different situations.
        """
        self.distribution = "norm"
        self.desired_units = "degreesC"
        self.predictor = "mean"
        self.no_of_realizations = 3
        data = np.array(
            [
                [[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]],
                [[1.0, 2.0, 3], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]],
                [[2.0, 3.0, 4.0], [5.0, 6.0, 7.0], [8.0, 9.0, 10.0]],
            ]
        )
        data = data + 273.15
        data = data.astype(np.float32)
        cube = _create_multi_date_cube(data)

        self.historic_forecast_predictor_mean = cube.collapsed(
            "realization", iris.analysis.MEAN
        )
        self.historic_forecast_predictor_realizations = cube.copy()
        self.truth = cube.collapsed("realization", iris.analysis.MAX)
        # Set up a version of the same cube but with a masked halo surrounding
        # the original data.
        data = np.array(
            [
                [
                    [np.nan, np.nan, np.nan, np.nan, np.nan],
                    [np.nan, 0.0, 1.0, 2.0, np.nan],
                    [np.nan, 3.0, 4.0, 5.0, np.nan],
                    [np.nan, 6.0, 7.0, 8.0, np.nan],
                    [np.nan, np.nan, np.nan, np.nan, np.nan],
                ],
                [
                    [np.nan, np.nan, np.nan, np.nan, np.nan],
                    [np.nan, 1.0, 2.0, 3, np.nan],
                    [np.nan, 4.0, 5.0, 6.0, np.nan],
                    [np.nan, 7.0, 8.0, 9.0, np.nan],
                    [np.nan, np.nan, np.nan, np.nan, np.nan],
                ],
                [
                    [np.nan, np.nan, np.nan, np.nan, np.nan],
                    [np.nan, 2.0, 3.0, 4.0, np.nan],
                    [np.nan, 5.0, 6.0, 7.0, np.nan],
                    [np.nan, 8.0, 9.0, 10.0, np.nan],
                    [np.nan, np.nan, np.nan, np.nan, np.nan],
                ],
            ]
        )
        data = data + 273.15
        data = data.astype(np.float32)
        data = np.ma.masked_invalid(data)
        cube = _create_multi_date_cube(data)

        # Note that when numpy collapses masked arrays it modifies the data
        # type so we convert it back to float32.
        self.historic_forecast_predictor_mean_masked_halo = cube.collapsed(
            "realization", iris.analysis.MEAN
        )
        self.historic_forecast_predictor_mean_masked_halo.data = self.historic_forecast_predictor_mean_masked_halo.data.astype(
            np.float32
        )
        self.historic_forecast_predictor_realizations_masked_halo = cube.copy()
        self.truth_masked_halo = cube.collapsed("realization", iris.analysis.MAX)
        self.truth_masked_halo.data = self.truth_masked_halo.data.astype(np.float32)

        # Set up expected results:
        # Set up results for the case where the
        # estimate_coefficients_from_linear_model_flag is False
        self.expected_mean_predictor_no_linear_model = np.array(
            [0, 1, 0, 1], dtype=np.float32
        )
        self.expected_realizations_predictor_no_linear_model = np.array(
            [
                0,
                np.sqrt(1.0 / self.no_of_realizations),
                np.sqrt(1.0 / self.no_of_realizations),
                np.sqrt(1.0 / self.no_of_realizations),
                0,
                1,
            ],
            dtype=np.float32,
        )
        # Set up results for the case where the
        # estimate_coefficients_from_linear_model_flag is True
        self.expected_mean_predictor_with_linear_model = np.array(
            [1.0, 1.0, 0.0, 1.0], dtype=np.float32
        )
        self.expected_realizations_predictor_with_linear_model = np.array(
            [0.666667, 0.0, 0.333333, 0.666667, 0.0, 1.0], dtype=np.float32
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_basic_mean_predictor(self):
        """
        Test that the plugin returns the expected values for the initial guess
        for the calibration coefficients, when the ensemble mean is used
        as the predictor. As coefficients are not estimated using a
        linear model, the default values for the initial guess are used.
        """
        estimate_coefficients_from_linear_model_flag = False

        plugin = Plugin(self.distribution, desired_units=self.desired_units)
        result = plugin.compute_initial_guess(
            self.truth,
            self.historic_forecast_predictor_mean,
            self.predictor,
            estimate_coefficients_from_linear_model_flag,
            None,
        )
        self.assertIsInstance(result, np.ndarray)
        self.assertArrayAlmostEqual(
            result, self.expected_mean_predictor_no_linear_model
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_basic_realizations_predictor(self):
        """
        Test that the plugin returns the expected values for the initial guess
        for the calibration coefficients, when the individual ensemble
        realizations are used as predictors. As coefficients are not estimated
        using a linear model, the default values for the initial guess
        are used.
        """
        predictor = "realizations"
        estimate_coefficients_from_linear_model_flag = False

        plugin = Plugin(self.distribution, desired_units=self.desired_units)
        result = plugin.compute_initial_guess(
            self.truth,
            self.historic_forecast_predictor_realizations,
            predictor,
            estimate_coefficients_from_linear_model_flag,
            self.no_of_realizations,
        )
        self.assertIsInstance(result, np.ndarray)
        self.assertArrayAlmostEqual(
            result, self.expected_realizations_predictor_no_linear_model
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_mean_predictor_estimate_coefficients(self):
        """
        Test that the plugin returns the expected values for the initial guess
        for the calibration coefficients, when the ensemble mean is used
        as the predictor. The coefficients are estimated using a linear model,
        where there is an offset of one between the truth and the forecast
        during the training period. Therefore, in this case the result of the
        linear regression is a gradient of 1 and an intercept of 1.
        """
        estimate_coefficients_from_linear_model_flag = True

        plugin = Plugin(self.distribution, desired_units=self.desired_units)
        result = plugin.compute_initial_guess(
            self.truth,
            self.historic_forecast_predictor_mean,
            self.predictor,
            estimate_coefficients_from_linear_model_flag,
            None,
        )

        self.assertArrayAlmostEqual(
            self.expected_mean_predictor_with_linear_model, result
        )

    @unittest.skipIf(STATSMODELS_FOUND is False, "statsmodels module not available.")
    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_realizations_predictor_estimate_coefficients(self):
        """
        Test that the plugin returns the expected values for the initial guess
        for the calibration coefficients, when the ensemble mean is used
        as the predictor. The coefficients are estimated using a linear model.
        In this case, the result of the linear regression is for an intercept
        of 0.333333 with different weights for the realizations because
        some of the realizations are closer to the truth, in this instance.
        """
        import statsmodels.api as sm
        predictor = "realizations"
        estimate_coefficients_from_linear_model_flag = True

        plugin = Plugin(self.distribution, desired_units=self.desired_units)
        result = plugin.compute_initial_guess(
            self.truth,
            self.historic_forecast_predictor_realizations,
            predictor,
            estimate_coefficients_from_linear_model_flag,
            self.no_of_realizations,
            sm=sm
        )
        self.assertArrayAlmostEqual(
            self.expected_realizations_predictor_with_linear_model, result
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_mean_predictor_estimate_coefficients_masked_halo(self):
        """
        Test that the plugin returns the expected values for the initial guess
        for the calibration coefficients, when the ensemble mean is used
        as the predictor. The coefficients are estimated using a linear model,
        where there is an offset of one between the truth and the forecast
        during the training period. Therefore, in this case the result of the
        linear regression is a gradient of 1 and an intercept of 1. In this
        case the original data has been surrounded by a halo of masked nans,
        which gives the same coefficients as the original data.
        """
        estimate_coefficients_from_linear_model_flag = True

        plugin = Plugin(self.distribution, desired_units=self.desired_units)
        result = plugin.compute_initial_guess(
            self.truth_masked_halo,
            self.historic_forecast_predictor_mean_masked_halo,
            self.predictor,
            estimate_coefficients_from_linear_model_flag,
            None,
        )
        self.assertArrayAlmostEqual(
            self.expected_mean_predictor_with_linear_model, result
        )

    @unittest.skipIf(STATSMODELS_FOUND is False, "statsmodels module not available.")
    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_realizations_predictor_estimate_coefficients_masked_halo(self):
        """
        Test that the plugin returns the expected values for the initial guess
        for the calibration coefficients, when the ensemble mean is used
        as the predictor. The coefficients are estimated using a linear model.
        In this case, the result of the linear regression is for an intercept
        of 0.333333 with different weights for the realizations because
        some of the realizations are closer to the truth, in this instance. In
        this case the original data has been surrounded by a halo of masked
        nans, which gives the same coefficients as the original data.
        """
        import statsmodels.api as sm
        predictor = "realizations"
        estimate_coefficients_from_linear_model_flag = True

        plugin = Plugin(self.distribution, desired_units=self.desired_units)
        result = plugin.compute_initial_guess(
            self.truth_masked_halo,
            self.historic_forecast_predictor_realizations_masked_halo,
            predictor,
            estimate_coefficients_from_linear_model_flag,
            self.no_of_realizations,
            sm=sm
        )
        self.assertArrayAlmostEqual(
            self.expected_realizations_predictor_with_linear_model, result
        )


class Test_mask_cube(SetupCubes):
    """Test the mask_cube method"""

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def setUp(self):
        """Set up additional cube for land-sea mask."""
        super().setUp()
        mask_data = np.array([[0, 1, 0], [0, 1, 1], [1, 1, 0]], dtype=np.int32)
        self.mask_cube = set_up_variable_cube(
            mask_data, name="land_binary_mask", units="1"
        )
        self.plugin = Plugin("norm")
        # Copy a few slices of the temperature truth cube to test on.
        self.cube3D = self.temperature_truth_cube[0:2, ...].copy()

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_basic(self):
        """Test that a simple cube is masked in the correct way."""
        expected_result = np.array(
            [
                [
                    [np.nan, 273.15, np.nan],
                    [np.nan, 275.75, 276.55],
                    [278.05, 278.35, np.nan],
                ],
                [
                    [np.nan, 273.35, np.nan],
                    [np.nan, 275.95, 276.75],
                    [278.25, 278.55002, np.nan],
                ],
            ],
            dtype=np.float32,
        )
        expected_result = np.ma.masked_invalid(expected_result)
        self.plugin.mask_cube(self.cube3D, self.mask_cube)
        # print("self.cube3D.data.data = ", self.cube3D.data.data)
        # print("self.temperature_truth_cube = ", self.temperature_truth_cube.data)
        self.assertArrayAlmostEqual(expected_result.data, self.cube3D.data.data)
        self.assertArrayEqual(
            np.ma.getmask(expected_result), np.ma.getmask(self.cube3D.data)
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_basic_2D_input_cube(self):
        """Test that a simple 2D cube is masked in the correct way."""
        cube2D = self.cube3D[0].copy()
        expected_result = np.array(
            [
                [np.nan, 273.15, np.nan],
                [np.nan, 275.75, 276.55],
                [278.05, 278.35, np.nan],
            ],
            dtype=np.float32,
        )
        expected_result = np.ma.masked_invalid(expected_result)
        self.plugin.mask_cube(cube2D, self.mask_cube)
        self.assertArrayAlmostEqual(expected_result.data, cube2D.data.data)
        self.assertArrayEqual(
            np.ma.getmask(expected_result), np.ma.getmask(cube2D.data)
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_fail_mismatched_arrays(self):
        """Test that an error is raised when input have incompatible shapes."""
        cube_mismatched = self.cube3D[..., 0].copy()
        msg = "Cube and landsea_mask shapes are not compatible."
        with self.assertRaisesRegex(IndexError, msg):
            self.plugin.mask_cube(cube_mismatched, self.mask_cube)

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_fail_transposed_input(self):
        """Test that an error is raised when the input cube is transposed"""
        self.cube3D.transpose((2, 0, 1))
        msg = "Cube and landsea_mask shapes are not compatible."
        with self.assertRaisesRegex(IndexError, msg):
            self.plugin.mask_cube(self.cube3D, self.mask_cube)


class Test_process(
    SetupCubes, EnsembleCalibrationAssertions, SetupExpectedCoefficients
):

    """Test the process method"""

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def setUp(self):
        """Set up multiple cubes for testing."""
        super().setUp()
        self.distribution = "norm"

        landsea_data = np.array(
            [
                [0, 0, 0, 0, 0],
                [0, 1, 1, 1, 0],
                [0, 1, 1, 1, 0],
                [0, 1, 1, 1, 0],
                [0, 0, 0, 0, 0],
            ],
            dtype=np.int32,
        )
        self.landsea_cube = set_up_variable_cube(
            landsea_data, name="land_binary_mask", units="1"
        )
        self.plugin = partial(Plugin, tolerance=0.01)

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_basic(self):
        """Ensure that the optimised_coefficients are returned as a cube,
        with the expected number of coefficients."""
        plugin = self.plugin(self.distribution)
        result = plugin.process(
            self.historic_temperature_forecast_cube, self.temperature_truth_cube
        )
        self.assertIsInstance(result, iris.cube.CubeList)
        self.assertEqual(len(result), len(self.coeff_names))

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficient_values_for_norm_distribution(self):
        """Ensure that the values for the optimised_coefficients match the
        expected values, and the coefficient names also match
        expected values for a normal distribution. In this case,
        a linear least-squares regression is used to construct the initial
        guess."""
        plugin = self.plugin(self.distribution)
        result = plugin.process(
            self.historic_temperature_forecast_cube, self.temperature_truth_cube
        )

        self.assertEMOSCoefficientsAlmostEqual(
            np.array([cube.data for cube in result]), self.expected_mean_predictor_norm,
        )
        self.assertArrayEqual(
            [cube.name() for cube in result], self.expected_coeff_names
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficient_values_for_norm_distribution_landsea_mask(self):
        """Ensure that the values for the optimised_coefficients match the
        expected values, and the coefficient names also match
        expected values for a normal distribution. In this case,
        a linear least-squares regression is used to construct the initial
        guess. The original data is surrounded by a halo that is masked
        out by the landsea_mask, giving the same results as the original data.
        """
        plugin = self.plugin(self.distribution)
        result = plugin.process(
            self.historic_temperature_forecast_cube_halo,
            self.temperature_truth_cube_halo,
            landsea_mask=self.landsea_cube,
        )

        self.assertEMOSCoefficientsAlmostEqual(
            np.array([cube.data for cube in result]), self.expected_mean_predictor_norm,
        )
        self.assertArrayEqual(
            [cube.name() for cube in result], self.expected_coeff_names
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficient_values_for_norm_distribution_mismatching_inputs(self):
        """Test that the values for the optimised coefficients match the
        expected values, and the coefficient names also match
        expected values for a normal distribution for when the historic
        forecasts and truths input having some mismatches in validity time.
        """
        expected = [25.2214, 0.9067, 0.0013, 0.4828]
        partial_historic_forecasts = (
            self.historic_forecasts[:2] + self.historic_forecasts[3:]
        ).merge_cube()
        partial_truth = self.truth[1:].merge_cube()
        plugin = self.plugin(self.distribution)
        result = plugin.process(partial_historic_forecasts, partial_truth)

        self.assertEMOSCoefficientsAlmostEqual(
            np.array([cube.data for cube in result]), expected
        )
        self.assertArrayEqual(
            [cube.name() for cube in result], self.expected_coeff_names
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficients_norm_distribution_default_initial_guess(self):
        """Ensure that the values for the optimised_coefficients match the
        expected values, and the coefficient names also match
        expected values for a normal distribution, where the
        default values for the initial guess are used, rather than using a
        linear least-squares regression to construct an initial guess.
        Reducing the value for the tolerance would result in the coefficients
        more closely matching the coefficients created when using a linear
        least-squares regression to construct the initial guess."""
        expected = [-0.0001, 0.9974, 0.0001, 1.0374]
        plugin = self.plugin(self.distribution)
        plugin.ESTIMATE_COEFFICIENTS_FROM_LINEAR_MODEL_FLAG = False
        result = plugin.process(
            self.historic_temperature_forecast_cube, self.temperature_truth_cube
        )

        self.assertEMOSCoefficientsAlmostEqual(
            np.array([cube.data for cube in result]), expected
        )
        self.assertArrayEqual(
            [cube.name() for cube in result], self.expected_coeff_names
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficient_values_for_norm_distribution_max_iterations(self):
        """Ensure that the values for the optimised_coefficients match the
        expected values, and the coefficient names also match
        expected values for a normal distribution, when the max_iterations
        argument is specified."""
        max_iterations = 800

        plugin = self.plugin(self.distribution, max_iterations=max_iterations)
        result = plugin.process(
            self.historic_temperature_forecast_cube, self.temperature_truth_cube
        )

        self.assertEMOSCoefficientsAlmostEqual(
            np.array([cube.data for cube in result]), self.expected_mean_predictor_norm,
        )
        self.assertArrayEqual(
            [cube.name() for cube in result], self.expected_coeff_names
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficient_values_for_truncnorm_distribution(self):
        """Ensure that the values for the optimised_coefficients match the
        expected values, and the coefficient names also match
        expected values for a truncated normal distribution. In this case,
        a linear least-squares regression is used to construct the initial
        guess."""
        distribution = "truncnorm"

        plugin = self.plugin(distribution)
        result = plugin.process(
            self.historic_wind_speed_forecast_cube, self.wind_speed_truth_cube
        )

        self.assertEMOSCoefficientsAlmostEqual(
            np.array([cube.data for cube in result]),
            self.expected_mean_predictor_truncnorm,
        )
        self.assertArrayEqual(
            [cube.name() for cube in result], self.expected_coeff_names
        )
        for cube in result:
            self.assertArrayEqual(
                cube.attributes["shape_parameters"],
                np.array([0, np.inf], dtype=np.float32),
            )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficient_values_for_truncnorm_distribution_mask(self):
        """Ensure that the values for the optimised_coefficients match the
        expected values, and the coefficient names also match
        expected values for a truncated normal distribution. In this case,
        a linear least-squares regression is used to construct the initial
        guess.The original data is surrounded by a halo that is masked
        out by the land-sea mask, giving the same results as the original data.
        """
        distribution = "truncnorm"

        plugin = self.plugin(distribution)
        result = plugin.process(
            self.historic_wind_speed_forecast_cube_halo,
            self.wind_speed_truth_cube_halo,
            landsea_mask=self.landsea_cube,
        )

        self.assertEMOSCoefficientsAlmostEqual(
            np.array([cube.data for cube in result]),
            self.expected_mean_predictor_truncnorm,
        )
        self.assertArrayEqual(
            [cube.name() for cube in result], self.expected_coeff_names
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficients_truncnorm_default_initial_guess(self):
        """Ensure that the values for the optimised_coefficients match the
        expected values, and the coefficient names also match
        expected values for a truncated normal distribution, where the
        default values for the initial guess are used, rather than using a
        linear least-squares regression to construct an initial guess.
        Reducing the value for the tolerance would result in the coefficients
        more closely matching the coefficients created when using a linear
        least-squares regression to construct the initial guess."""
        expected = [-0.0, 0.8652, 0.0002, 1.0777]
        distribution = "truncnorm"

        plugin = self.plugin(distribution)
        plugin.ESTIMATE_COEFFICIENTS_FROM_LINEAR_MODEL_FLAG = False
        result = plugin.process(
            self.historic_wind_speed_forecast_cube, self.wind_speed_truth_cube
        )

        self.assertEMOSCoefficientsAlmostEqual(
            np.array([cube.data for cube in result]), expected
        )
        self.assertArrayEqual(
            [cube.name() for cube in result], self.expected_coeff_names
        )

    @unittest.skipIf(STATSMODELS_FOUND is False, "statsmodels module not available.")
    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficients_norm_realizations_statsmodels(self):
        """Ensure that the values for the optimised_coefficients match the
        expected values, and the coefficient names also match
        expected values for a normal distribution where the
        realizations are used as the predictor."""
        predictor = "realizations"

        plugin = self.plugin(self.distribution, predictor=predictor)
        result = plugin.process(
            self.historic_temperature_forecast_cube, self.temperature_truth_cube
        )

        self.assertEMOSCoefficientsAlmostEqual(
            np.concatenate([np.atleast_1d(cube.data) for cube in result]),
            self.expected_realizations_norm_statsmodels,
        )
        self.assertArrayEqual(
            [cube.name() for cube in result], self.expected_coeff_names
        )

    @unittest.skipIf(STATSMODELS_FOUND is True, "statsmodels module is available.")
    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficients_norm_realizations_no_statsmodels(self):
        """Ensure that the values for the optimised_coefficients match the
        expected values, and the coefficient names also match
        expected values for a normal distribution where the
        realizations are used as the predictor.
        """
        predictor = "realizations"

        plugin = self.plugin(self.distribution, predictor=predictor)
        result = plugin.process(
            self.historic_temperature_forecast_cube, self.temperature_truth_cube
        )
        self.assertEMOSCoefficientsAlmostEqual(
            np.concatenate([np.atleast_1d(cube.data) for cube in result]),
            self.expected_realizations_norm_no_statsmodels,
        )
        self.assertArrayEqual(
            [cube.name() for cube in result], self.expected_coeff_names
        )

    @unittest.skipIf(STATSMODELS_FOUND is False, "statsmodels module not available.")
    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficients_truncnorm_realizations_statsmodels(self):
        """Ensure that the values for the optimised_coefficients match the
        expected values, and the coefficient names also match
        expected values for a truncated normal distribution where the
        realizations are used as the predictor."""
        distribution = "truncnorm"
        predictor = "realizations"

        plugin = self.plugin(distribution, predictor=predictor)
        result = plugin.process(
            self.historic_wind_speed_forecast_cube, self.wind_speed_truth_cube
        )
        self.assertEMOSCoefficientsAlmostEqual(
            np.concatenate([np.atleast_1d(cube.data) for cube in result]),
            self.expected_realizations_truncnorm_statsmodels,
        )
        self.assertArrayEqual(
            [cube.name() for cube in result], self.expected_coeff_names
        )

    @unittest.skipIf(STATSMODELS_FOUND is True, "statsmodels module is available.")
    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_coefficients_truncnorm_realizations_no_statsmodels(self):
        """Ensure that the values for the optimised_coefficients match the
        expected values, and the coefficient names also match
        expected values for a truncated normal distribution where the
        realizations are used as the predictor."""
        distribution = "truncnorm"
        predictor = "realizations"

        plugin = self.plugin(distribution, predictor=predictor)
        result = plugin.process(
            self.historic_wind_speed_forecast_cube, self.wind_speed_truth_cube
        )
        # np.set_printoptions(suppress=True)
        # for cube in result:
        #     print(cube.data)
        # #print(np.array([cube.data for cube in result]))

        # print("result = ", result)
        self.assertEMOSCoefficientsAlmostEqual(
            np.concatenate([np.atleast_1d(cube.data) for cube in result]),
            self.expected_realizations_truncnorm_no_statsmodels,
        )
        self.assertArrayEqual(
            [cube.name() for cube in result], self.expected_coeff_names
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_each_point(self):
        """Test computing coefficients independently for each grid point (initial guess
        and minimising) returns the expected coefficients and associated metadata."""
        expected = {
            "emos_coefficient_alpha": np.array(
                [
                    [0.0896, -0.0555, -1.0103],
                    [-0.8949, -0.8790, -0.9117],
                    [-0.5823, -1.0073, -1.0740],
                ]
            ),
            "emos_coefficient_beta": np.array(
                [
                    [0.9999, 1.0001, 1.0005],
                    [1.0009, 1.0006, 1.0006],
                    [1.0005, 1.0005, 1.0004],
                ]
            ),
            "emos_coefficient_gamma": np.array(
                [
                    [0.0010, 0.0010, 0.0016],
                    [0.0010, 0.0014, 0.0013],
                    [0.0011, 0.0018, 0.0018],
                ]
            ),
            "emos_coefficient_delta": np.array(
                [
                    [0.0022, 0.0028, 0.0021],
                    [-0.0039, 0.0016, 0.0007],
                    [-0.0029, 0.0043, 0.0030],
                ]
            ),
        }
        plugin = Plugin(self.distribution, each_point=True)
        result = plugin.process(
            self.historic_temperature_forecast_cube, self.temperature_truth_cube
        )
        for cube in result:
            self.assertEMOSCoefficientsAlmostEqual(
                cube.data, expected[cube.name()],
            )
            self.assertIn(cube.name(), self.expected_coeff_names)
            self.assertEqual(
                [c.name() for c in cube.coords(dim_coords=True)],
                ["latitude", "longitude"],
            )

    # @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    # def test_each_point_landsea_mask(self):
    #     """Ensure that the values for the optimised_coefficients match the
    #     expected values, and the coefficient names also match
    #     expected values for a normal distribution. In this case,
    #     a linear least-squares regression is used to construct the initial
    #     guess. The original data is surrounded by a halo that is masked
    #     out by the landsea_mask, giving the same results as the original data.
    #     """
    #     expected = {
    #         "emos_coefficient_alpha": np.array(
    #             [
    #                 [0.0896, -0.0555, -1.0103],
    #                 [-0.8949, -0.8790, -0.9117],
    #                 [-0.5823, -1.0073, -1.0740],
    #             ]
    #         ),
    #         "emos_coefficient_beta": np.array(
    #             [
    #                 [0.9999, 1.0001, 1.0005],
    #                 [1.0009, 1.0006, 1.0006],
    #                 [1.0005, 1.0005, 1.0004],
    #             ]
    #         ),
    #         "emos_coefficient_gamma": np.array(
    #             [
    #                 [0.0010, 0.0010, 0.0016],
    #                 [0.0010, 0.0014, 0.0013],
    #                 [0.0011, 0.0018, 0.0018],
    #             ]
    #         ),
    #         "emos_coefficient_delta": np.array(
    #             [
    #                 [0.0022, 0.0028, 0.0021],
    #                 [-0.0039, 0.0016, 0.0007],
    #                 [-0.0029, 0.0043, 0.0030],
    #             ]
    #         ),
    #     }

    #     plugin = Plugin(self.distribution, each_point=True)
    #     result = plugin.process(
    #         self.historic_temperature_forecast_cube_halo,
    #         self.temperature_truth_cube_halo,
    #         landsea_mask=self.landsea_cube,
    #     )

    #     for cube in result:
    #         self.assertEMOSCoefficientsAlmostEqual(
    #             cube.data, expected[cube.name()],
    #         )
    #         self.assertIn(cube.name(), self.expected_coeff_names)
    #         self.assertEqual(
    #             [c.name() for c in cube.coords(dim_coords=True)],
    #             ["latitude", "longitude"],
    #         )

        # self.assertEMOSCoefficientsAlmostEqual(
        #     np.array([cube.data for cube in result]), self.expected_mean_predictor_norm,
        # )
        # self.assertArrayEqual(
        #     [cube.name() for cube in result], self.expected_coeff_names
        # )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_minimise_each_point(self):
        """Test computing coefficients independently for each grid point
        (minimisation only) returns the expected coefficients and associated metadata."""
        expected = {
            "emos_coefficient_alpha": np.array(
                [
                    [0.0037, 0.0017, -0.0002],
                    [-0.0002, -0.0001, 0.0],
                    [0.0031, 0.0051, -0.0001],
                ]
            ),
            "emos_coefficient_beta": np.array(
                [
                    [1.0002, 0.9999, 0.9969],
                    [0.9978, 0.9974, 0.9973],
                    [0.9984, 0.9969, 0.9966],
                ]
            ),
            "emos_coefficient_gamma": np.array(
                [
                    [0.0007, 0.0010, 0.0002],
                    [0.0002, 0.0001, 0.0002],
                    [0.0015, -0.0009, 0.0002],
                ]
            ),
            "emos_coefficient_delta": np.array(
                [
                    [-0.0009, -0.0016, 1.0320],
                    [1.0411, 1.0384, 1.0237],
                    [0.0025, -0.0039, 1.0338],
                ]
            ),
        }
        plugin = Plugin(self.distribution, minimise_each_point=True)
        result = plugin.process(
            self.historic_temperature_forecast_cube, self.temperature_truth_cube
        )
        for cube in result:
            self.assertEMOSCoefficientsAlmostEqual(
                cube.data, expected[cube.name()],
            )
            self.assertIn(cube.name(), self.expected_coeff_names)
            self.assertEqual(
                [c.name() for c in cube.coords(dim_coords=True)],
                ["latitude", "longitude"],
            )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_truth_unit_conversion(self):
        """Ensure the expected optimised coefficients are generated,
        even if the input truth cube has different units."""
        self.temperature_truth_cube.convert_units("Fahrenheit")
        desired_units = "Kelvin"

        plugin = self.plugin(self.distribution, desired_units=desired_units)
        result = plugin.process(
            self.historic_temperature_forecast_cube, self.temperature_truth_cube
        )

        self.assertEMOSCoefficientsAlmostEqual(
            np.array([cube.data for cube in result]), self.expected_mean_predictor_norm,
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_historic_forecast_unit_conversion(self):
        """Ensure the expected optimised coefficients are generated,
        even if the input historic forecast cube has different units."""
        self.historic_temperature_forecast_cube.convert_units("Fahrenheit")
        desired_units = "Kelvin"

        plugin = self.plugin(self.distribution, desired_units=desired_units)
        result = plugin.process(
            self.historic_temperature_forecast_cube, self.temperature_truth_cube
        )

        self.assertEMOSCoefficientsAlmostEqual(
            np.array([cube.data for cube in result]), self.expected_mean_predictor_norm,
        )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_non_matching_units(self):
        """Test that an exception is raised if the historic forecasts and truth
        have non matching units."""
        self.historic_temperature_forecast_cube.convert_units("Fahrenheit")

        plugin = self.plugin(self.distribution)

        msg = "The historic forecast units"
        with self.assertRaisesRegex(ValueError, msg):
            plugin.process(
                self.historic_temperature_forecast_cube, self.temperature_truth_cube
            )

    @ManageWarnings(ignored_messages=IGNORED_MESSAGES, warning_types=WARNING_TYPES)
    def test_missing_cube(self):
        """Test that an exception is raised if either of the  historic
        forecasts or truth were missing."""
        self.historic_temperature_forecast_cube.convert_units("Fahrenheit")

        plugin = self.plugin(self.distribution)

        msg = ".*cubes must be provided"
        with self.assertRaisesRegex(ValueError, msg):
            plugin.process(self.historic_temperature_forecast_cube, None)


if __name__ == "__main__":
    unittest.main()
